### Docker Intro

This document provides a quickstart guide for getting [MCAG_setupMotionDemo](https://github.com/EuropeanSpallationSource/MCAG_setupMotionDemo) running in a Docker container on Linux.

#### Installation

The easiest way to install Docker is using an installation script hosted on their website:
```
$ sudo apt-get update
$ sudo apt-get install curl 
$ curl -fsSL https://get.docker.com/ | sh
```
Detailed guides for installing and setting it up manually exist on their [documentation page](https://docs.docker.com/engine/installation/linux/ubuntulinux/).

To test that it works, you can run the provided hello-world image:
```
# docker run hello-world
```
Note that you have to be root to use docker by default. 

You can add yourself to the `docker` group to circumvent this, but this is not recommended for production environments due to [security risks](https://fosterelli.co/privilege-escalation-via-docker.html):
```
$ sudo usermod -aG docker $USER
$ newgrp docker
$ sudo service docker restart
$ docker run hello-world
```

#### Running an Existing Image

You can download an existing image by issuing a `pull` command. This isn't strictly necessary, because attempting to `run` an image will automatically try to `pull` if the image isn't found locally, but preloading can be useful sometimes. In this case, it's good to see the image startup speed separately from the time it takes to download.

To download the MCAG_setupMotionDemo image I've created on [the Docker Hub](https://hub.docker.com/r/mikehart/motorsim/), run the following:
```
$ docker pull mikehart/motorsim
```
This will download several image layers; the ones that are part of the motorsim image itself, and the ones that are part of the Ubuntu 14.04 image that motorsim is based on (assuming you don't already having them). 

To see all images you have available locally, you can run:
```
$ docker images
```
Once the pull is finished, you can run the motorsim image by executing:
```
$ docker run -it mikehart/motorsim
```
This will create a new container based on the motorsim image and run it in **-i**nteractive **-t**ty mode. Since the image has a startup script that runs by default, it should immediately start up the simulator and the IOC and drop you into the `epics>` prompt. You can run `dbl` to verify that PVs IOC:m1 through IOC:m4 are available. 

Perhaps we don't need the `epics>` prompt anymore, but we want the sim to continue running. Press `ctrl-p`, `ctrl-q` to detach from the container. To verify it's still running, you can tell Docker to list **-a**ll (running and stopped) containers:
```
$ docker ps -a
```
You'll see motorsim listed with an "Up" status and hello-world listed with an "Exited" status (if you ran it previously). Containers are not destroyed when they exit, so that you can restart them again later without losing any changes that happened while they were running. Containers are identified by a unique hash ID and a name (auto-generated by default). 

You can delete containers you don't need anymore using:
```
$ docker rm [ID|name]
```

#### Networking Between Containers

Docker creates a bridged network on install called "docker0". It has an IP range of 172.17.0.0/16 by default.

The host machine is assigned IP 172.17.0.1, and containers are assigned subsequent free IPs ending in .2, .3, etc. Each container also has its own separate localhost by default.

You can control all of this, create custom bridged networks, attach containers directly to your host's eth0 network, make containers share the same localhost, and more. But this is beyond the scope of this guide and won't be necessary here. We just want to talk Channel Access on the default bridged network for now.

If you followed the previous section, a motorsim container should still be running in the background. You can check using:
```
$ docker ps -a
```
If it's not, you can start a new one in **-d**etached mode using:
```
$ docker run -itd mikehart/motorsim
```
Actually, it would be nice to see the sim reacting as we talk to it... so let's attach it to the terminal again. You'll need the generated name or ID from the `ps -a` command. In my case, it was named "desperate_hypatia":
```
$ docker attach desperate_hypatia
```
You'll need to press Enter to get the `epics>` prompt to show up again.

Since the motorsim image is set up for talking on the docker0 network and has EPICS installed, it would be convenient to use it for this as well. But we don't want the startup script to launch another instance of the sim and IOC.

In another terminal, run this command:
```
$ docker run -it --rm mikehart/motorsim bash
```
The `--rm` switch just makes the container delete itself once it exits. We just need a temporary container to test something, so no need to clog up the `ps -a` list.

The important difference is the `bash` parameter passed at the end. This overrides the default command, which is to run "/startup.sh", and tells the container to just run `bash` on startup instead. You should get a root prompt that looks something like:
```
root@123456abcdef:/# 
```
This is a shell inside the container. The hexadecimal number is the ID of this container (and its hostname). You can browse around for a while. The startup script is in `/` and all the sim related files are in `/MCAG_setupMotionDemo`. `nano` is available as an editor.

The environment in this image is already set up for EPICS to talk on the bridged network, so you can just run `caget` and `caput` commands like this:
```
root@123456abcdef:/# caget IOC:m1
root@123456abcdef:/# caput IOC:m2 20
```
When done, you can just `exit` out of the shell. The container will shut down and, since we supplied the `--rm` parameter, self-destruct so that it won't show up in `ps -a` anymore.

Try running multiple containers like this in several terminals, and take note of system resource usage.

If you have EPICS installed on your host, you can also talk to the containers directly. Just set the following environment variables:
```
$ export EPICS_CA_ADDR_LIST=172.17.255.255
$ export EPICS_CA_AUTO_ADDR_LIST=NO
$ caget IOC:m1
```

#### Building the `motorsim` Image

This section describes how to build the MCAG_setupMotionDemo image that was used in the previous sections.

Images are built using a Dockerfile. This is similar to a Makefile; it just contains instructions for building the image. 

First a Dockerfile with the necessary build instructions needs to be created. The file should be in a folder of its own:
```
$ mkdir motorsim
$ cd motorsim
$ nano Dockerfile
```
Use your favorite editor and paste in the following:
```
FROM ubuntu:trusty

RUN apt-get update && apt-get install -y --no-install-recommends \
	build-essential \
	ca-certificates \
	git \
	libreadline-dev \
	nano \
	wget \
	&& rm -rf /var/lib/apt/lists/*

RUN git clone https://github.com/EuropeanSpallationSource/MCAG_setupMotionDemo.git \
	&& cd MCAG_setupMotionDemo \
	&& sed -i -- 's/read yesno/yesno=Y/g' install-epics.sh \
	&& ./setup.sh \
	&& mv ./.epics.$(hostname) ./.epics.motorsim \
	&& echo "export EPICS_CA_ADDR_LIST=172.17.255.255" >> ./.epics.motorsim \
	&& echo "export EPICS_CA_AUTO_ADDR_LIST=NO" >> ./.epics.motorsim \
	&& echo ". /MCAG_setupMotionDemo/.epics.motorsim" >> /root/.bashrc \
	&& echo "cp /MCAG_setupMotionDemo/.epics.motorsim /MCAG_setupMotionDemo/.epics.\$HOSTNAME" >> /root/.bashrc

COPY ./startup.sh /

CMD ["/startup.sh"]
```
The FROM statement means this image will be built on top of the existing official Ubuntu image that is tagged "trusty". Tags are used to differentiate between different versions with the same image name.

The first RUN statement installs prerequisites and some nice-to-haves. The apt/lists purge is to minimize image size.

The second RUN checks out and compiles the MCAG repository. It also makes some modifications to ensure the install happens without a prompt, and the environment is set up correctly on startup. Note that the hostname of containers changes to a new ID every time a container is created.

The COPY statement copies `startup.sh` from the current directory on the host into the root of the image. Of course, startup.sh needs to be created as well:
```
#!/bin/bash -il

# Launch motorsim components
caRepeater &

cd /MCAG_setupMotionDemo/m-epics-IcePAP/simulator
./doit.sh &

cd /MCAG_setupMotionDemo/m-epics-IcePAP/epicsIOC
./doit.sh

# Cleanup (We stay in epicsIOC/doit.sh while running)
PID_CAREP=`ps aux | grep caRepeater | grep -v grep | awk '{ print $2 }'`
PID_MOTOR=`ps aux | grep simMotor | grep -v grep | awk '{ print $2 }'`

echo "Killing simMotor PID=$PID_MOTOR"
kill $PID_MOTOR

echo "Killing caRepeater PID=$PID_CAREP"
kill $PID_CAREP
```
The CMD statement sets executing "/startup.sh" as the default action when a container is started. If any parameters are passed to the container, this is ignored.

Finally, run this command in the same directory as the Dockerfile to build the image and **-t**ag it as simply "motorsim":
```
$ docker build -t motorsim .
```
Once this is finished (it can take a while since we're checking out and building a lot here), you'll have a new image in your local registry:
```
$ docker images
$ docker run -it motorsim
```

#### Image vs Container

Both terms are used a lot on the context of Docker and the difference may not be immediately obvious.

A Docker image is a layered package that contains everything needed to run a "dockerized" application or environment. It consists of layers to minimize duplication of common parts (for example, two images based on Ubuntu 14.04 share the same base layer without duplicating it or needing to download it twice). Images can be built using `Dockerfile`s, shared via the DockerHub service, or exported to a tarfile for direct sharing.

A Docker container can be thought of as an instance of an image. A new container is created whenever you `run` an image. Containers don't copy the image, however. They use the image as a starting point and keep track of any changes made. In a sense, they are just an additional layer on top of the image. You can `diff` to see the changes and `commit` to create a new image that contains the changes.

Containers represent a sandbox for a process to run in. The process can be a shell that runs other processes or just a single process by itself. It can be run in the foreground or in the background. You can `detach` from a running foreground container and `attach` to a running background container. A running container can be `stop`ped and `restart`ed. When a container is stopped, it isn't deleted by default and can be `start`ed again later (maintaining the state of the its sandbox).

